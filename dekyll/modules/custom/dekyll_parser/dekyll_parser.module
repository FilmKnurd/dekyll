<?php

/**
 * Define the YAML front header separator.
 */
define('YAML_SEPARATOR', "---\n");

/**
 * @file
 * Read and Write Jekyll files.
 */

/**
 * Implements hook_ctools_plugin_directory().
 */
function dekyll_parser_ctools_plugin_directory($module, $plugin) {
  if ($module == 'dekyll_parser') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function dekyll_parser_ctools_plugin_api($module, $api) {
  if ($module == 'dekyll_parser' && in_array($api, 'config_sync', 'content_sync')) {
    return array('version' => 1);
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function dekyll_parser_ctools_plugin_type() {
  $plugins['config_sync'] = array(
    'classes' => array('class'),
    'process' => 'dekyll_parser_config_sync_plugin_process',
  );

  $plugins['content_sync'] = array(
    'classes' => array('class'),
    'process' => 'dekyll_parser_content_sync_plugin_process',
  );
  return $plugins;
}

/**
 * Add defaults values to the notifier plugins.
 */
function dekyll_parser_config_sync_plugin_process(&$plugin, $info) {
  $plugin += array(
    'description' => '',
    'options' => array(),
  );

  $plugin['options'] += array();
}

/**
 * Helper function to include CTools plugins and get a notifier plguin.
 *
 * @param $plugin_name
 *   The plugin that should be laoded.
 */
function dekyll_parser_get_config_sync($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('dekyll_parser', 'config_sync', $plugin_name);
}

/**
 * Helper function to include CTools plugins and get all notifier plugins.
 */
function dekyll_parser_get_config_syncs() {
  ctools_include('plugins');
  return ctools_get_plugins('dekyll_parser', 'config_sync');
}

/**
 * Add defaults values to the notifier plugins.
 */
function dekyll_parser_content_sync_plugin_process(&$plugin, $info) {
  $plugin += array(
    'description' => '',
    'options' => array(),
  );

  $plugin['options'] += array();
}

/**
 * Helper function to include CTools plugins and get a notifier plguin.
 *
 * @param $plugin_name
 *   The plugin that should be laoded.
 */
function dekyll_parser_get_content_sync($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('dekyll_parser', 'content_sync', $plugin_name);
}

/**
 * Helper function to include CTools plugins and get all notifier plugins.
 */
function dekyll_parser_get_content_syncs() {
  ctools_include('plugins');
  return ctools_get_plugins('dekyll_parser', 'content_sync');
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add a setting to group content fields, to determine whether they will be
 * displayed on the mini node form of the browsing widget.
 */
function dekyll_parser_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  $instance = $form['#instance'];
  $form['instance']['settings']['jekyll_map'] = array(
    '#title' => t('Jekyll variable name'),
    '#description' => t("Map this field to a Jekyll YAML variable (e.g Drupal's <code>field_tags</code> will map to Jekyll's <code>tags</code>)."),
    '#type' => 'textfield',
    '#default_value' => !empty($instance['settings']['jekyll_map']) ? $instance['settings']['jekyll_map'] : '',
  );
}

/**
 * Implements hook_node_insert().
 */
function dekyll_parser_node_insert($node) {
  dekyll_parser_write_file($node);
}

/**
 * Implements hook_node_update().
 */
function dekyll_parser_node_update($node) {
  dekyll_parser_write_file($node);
}

/**
 * Create a queue item, in order to write a node to file.
 *
 * @param $node
 *   The node to be written.
 */
function dekyll_parser_write_file($node) {
  if (!isset($node->field_file_path)) {
    return;
  }

  if (!empty($node->_dekyll_sync)) {
    // Node is created or updated on sync.
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);

  $queue = DrupalQueue::get('dekyll_write_file');
  $data = array(
    'gid' => $wrapper->{OG_AUDIENCE_FIELD}->value(array('identifier' => TRUE)),
    'nid' => $node->nid,
    // Get the branch of the node.
    'branch' => dekyll_parser_get_git_branch($node),
    'commit_message' => '',
  );
  $queue->createItem($data);
}

/**
 * Get the branch name from a group content.
 */
function dekyll_parser_get_git_branch($node) {
  $wrapper = entity_metadata_wrapper('node', $node);

  $gid = $wrapper->{OG_AUDIENCE_FIELD}->value(array('identifier' => TRUE));

  $vocabulary = taxonomy_vocabulary_machine_name_load('branch_' . $gid);
  foreach ($wrapper->{OG_VOCAB_FIELD}->value() as $term) {
    if ($term->vid == $vocabulary->vid) {
      return $term->name;
    }
  }
}



/**
 * Implements hook_cron_queue_info().
 *
 * @todo: Move worker callbacks into the module?
 */
function dekyll_parser_cron_queue_info() {
  $queues['dekyll_clone'] = array(
    'worker callback' => 'drush_dekyll_parser_dekyll_clone',
    'time' => 60,
  );

  $queues['dekyll_sync'] = array(
    'worker callback' => 'drush_dekyll_parser_dekyll_sync',
    'time' => 60,
  );

  $queues['dekyll_write_file'] = array(
    'worker callback' => 'drush_dekyll_parser_dekyll_write_file',
    'time' => 60,
  );

  return $queues;
}

